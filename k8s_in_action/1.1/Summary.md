# 1장 쿠버네티스 소개

### 1. 쿠버네티스가 생긴 이유
- Application이 거대해지면서, MSA로 세분화 함과 동시에 인프라 변경이 필요하기 때문이다.

- Application의 기능이 많아지면서, 모놀로스 Application의 단점인 상호의존성이 증가하고, 한번 재부팅 시 많은 Resource 가 소모된다. 또한, 트래픽이 증가할 때 상대적으로 비용이 저렴한 Scale out 을 하기 힘들다는 점이 부각되었기 때문이다.

- 모놀로스 Application에서 MSA로 세분화 하게 되면서, 각 Server마다 개발 환경이 다른 상황이 발생할 수 있다. Application에 일관적인 환경을 제공하기 위해서 필요성이 증대 되었다.

- 과거에는 개발팀이 Application 개발을 한 뒤 운영팀에 넘겨주어 각자의 역할을 분배해서 프로젝트를 진행했지만, 이제는 개발팀이 Application을 배포하고, 관리하는것이 더 낮다는 점을 깨달았다.
```
위의 이유를 통해 kubernetes가 등장하게 되었다.
```
### 2. container의 등장
- 컨테이너란, 동일한 호스트 시스템에 여러개의 서비스를 실행할 수 있다. 또한, 동시에 서로 다른 환경을 만들어 준다.

- 같은 역할을 하는 가상머신과의 차이점은 host OS와 동일한 커널에서 시스템 콜이 수행된다. 그 결과 하드웨어 에뮬레이트 단계가 없이 분리된 공간을 만들기 때문에 가상머신에 비해 오버헤드가 적다.

- 컨테이너 격리를 가능하게 해주는 매커니즘은 두가지가 있다.
    1. 리눅스 네임 스페이스(namespace)
        - 각 프로세스가 시스템에 대한 독립된 뷰만 볼수 있도록 한다.
        - 네임 스페이스의 종류는 마운트(mnt), 프로세스ID(pid), 네트워크(net), 프로세스간 통신(ipc), 호스트와 도메인 이름(uts), 사용자ID(user) 로 구성되어있다.
        - 
    2. 리눅스 컨트롤 그룹(cgroups)
        - 프로세스가 사용할 수 있는 리소스의 양을 제한한다.
        - 리소스는 CPU, 
### 3. 